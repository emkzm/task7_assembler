extrn GetUserNameA      : proc,
      GetComputerNameA  : proc,
      GetTempPathA      : proc,
      GetVersionExA     : proc,
      wsprintfA         : proc,
      MessageBoxA       : proc,
      ExitProcess       : proc

;   Структура OSVERSIONINFO
;   Для получения информации о версии ОС необходимо ввести следующую структуру:

<<<<<<< Updated upstream
OSVERSIONINFO struct
   dwOSVersionInfoSize dword ?
   dwMajorVersion      dword ?
   dwMinorVersion      dword ?
   dwBuildNumber       dword ?
   dwPlatformId        dword ?
   szCSDVersion        byte 128 dup(?)
OSVERSIONINFO ends

=======
>>>>>>> Stashed changes
;   Удобно ввести следующие макрозамены (с помощью директивы equ или =):
    szMAX_COMP_NAME equ 16
    szUNLEN         equ 257
    szMAX_PATH      equ 261

.data


;   Введите следующие глобальные переменные (заголовок окна и строка форматирования):	
    
<<<<<<< Updated upstream
    cap db '<заголовок окна>',       0
=======
    cap db 'Computer INFO',          0
>>>>>>> Stashed changes

    fmt db 'Username: %s',           0Ah,   ; 0Ah = \n in ASCII TABLE
           'Computer name: %s',      0Ah,
           'TMP Path: %s',           0Ah,
           'OS version: %d.%d.%d',   0

    


.code
Start proc
;   Пошаговая инструкция по написанию программы
;
;   HELLO!
;
;   1.  Объявление локальных переменных
;   Для хранения результатов вызовов функций WinAPI введем следующие локальные переменные :


    local _msg[1024]                :byte, ; В переменной _msg будет храниться результирующая строка размером до 1024 байт
      _username[szUNLEN]            :byte, ; имя пользователя
      _compname[szMAX_COMP_NAME]    :byte, ; название компьютера
      _temppath[szMAX_PATH]         :byte, ; путь до директории временных файлов
<<<<<<< Updated upstream
      _v                            :OSVERSIONINFO,
=======
>>>>>>> Stashed changes
      _size                         :dword

;   В переменной _msg будет храниться результирующая строка размером до 1024 байт. 
;   Байтовые переменные 
;   _username[szUNLEN], 
;   _compname[szMAX_COMP_NAME], 
;   _temppath[szMAX_PATH] 
<<<<<<< Updated upstream
;   нужны для хранения имени пользователя, названия компьютера и пути до директории временных файлов соответственно. 
;   Также для получения данных о системе нам потребуется локальный экземпляр структуры OSVERSIONINFO. Назовем его _v. 
=======
;   нужны для хранения 
;   имени пользователя, 
;   названия компьютера
;   и пути до директории временных файлов
;   соответственно. 
>>>>>>> Stashed changes
;   Последняя переменная, которую необходимо объявить, - это _size размера dword. 
;   Эта переменная необходима для передачи размера строк в функции 
;   (так как размер требуется передать по указателю, макрозамены для передачи мы использовать не можем).    


;   2.  Подготовка стека
;   Для того, чтобы начать работу с WinAPI, требуется подготовить стек: 
;   выровнять его в соответствии со стандартом __fastcall и выделить место под 5 аргументов:

    sub RSP, 8*5
    and SPL, 0F0h

;   3.  Получение имени пользователя, названия компьютера и пути до директории временных файлов
;   Для того чтобы получить имя пользователя, выполним следующие действия:

<<<<<<< Updated upstream

    mov _size, szUNLEN  ; поместим в переменную _size значение размера строки имени пользователя (szUNLEN)
    lea RCX, _username        ; загрузим АДРЕС строки и УКАЗАТЕЛЬ на ее размер в регистры RCX  
    lea RDX, _size      ; и RDX соответственно
    call GetUserNameA   ; вызовем функцию GetUserNameA

;   Далее необходимо получить название компьютера и путь до директории временных файлов с помощью функций 
;   GetComputerNameA, 
;   GetTempPathA. 
;  
;   Работа с ними осуществляется аналогично, за исключением того, что для последней функции порядок меняется: 
;   сначала передается указатель на размер, а затем адрес строки.

    mov _size, szMAX_COMP_NAME  ; поместим в переменную _size значение размера строки имени пользователя (szUNLEN)
    lea RCX, _compname        ; загрузим АДРЕС строки в регистр RCX  
    lea RDX, _size      ; и УКАЗАТЕЛЬ на ее размер в регистр RDX
    call GetComputerNameA   ; вызовем функцию GetComputerNameA

;   " за исключением того, что для последней функции порядок меняется: 
;           сначала передается указатель на размер, а затем адрес строки."

    mov _size, szMAX_COMP_NAME  ; поместим в переменную _size значение размера строки имени пользователя (szUNLEN)
    lea RCX, _size      ; и УКАЗАТЕЛЬ на ее размер в регистр RCX
    lea RDX, _temppath        ; загрузим АДРЕС строки в регистр RDX  
    call GetTempPathA   ; вызовем функцию GetTempPathA

;
;   4.  Получение сведений о системе
;   В первую очередь нужно очистить экземпляр структуры OSVERSIONINFO:

    xor AL,AL               ;   очистим регистр AL
    mov RCX, size _v        ;   занесем в регистр RCX размер экземпляра _v (mov RCX, size _v)
    lea RDI, _v             ;   загрузить в RDI адрес _v
    rep stosb [RDI]         ;   применим stos для всех полей структуры (rep stos byte ptr [RDI]) = (rep stosb [RDI]).

;   The STOS instruction copies the data item from AL (for bytes - STOSB), AX (for words - STOSW)
;   or EAX (for doublewords - STOSD) to the destination string, pointed to by ES:DI in memory.

;   Далее необходимо подготовить аргументы и вызвать GetVersionExA:

    mov _v.dwOSVersionInfoSize, size _v     ;   установим размер структуры и поместим его в _v.dwOSVersionInfoSize
    lea RCX, _v                             ;   поместим _v в RCX
    call GetVersionExA                      ;   вызовем GetVersionExA.
    
   
;   5.  Формирование отформатированной строки
;   Сформируем строку _msg с помощью функции wsprintfA:
    lea RCX, _msg       ;  поместим в регистр RCX адрес строки _msg
    lea RDX, fmt        ;  в RDX занесем адрес строки форматирования fmt
    lea R8, _username   ;  в регистры R8 и R9 поместим адреса _username и
    lea R9, _compname   ;  _compname соответственно
    lea RAX, _v  ;  поместим оставшиеся
    push RAX            ;  аргументы в стек
    lea RAX, _temppath
    push RAX
    call wsprintfA      ;  вызовем wsprintfA.
=======
    mov _size, szUNLEN          ; поместим в переменную _size значение размера строки имени пользователя (szUNLEN)
    lea RCX, _username          ; загрузим АДРЕС строки и УКАЗАТЕЛЬ на ее размер в регистры RCX  
    lea RDX, _size              ; и RDX соответственно
    call GetUserNameA           ; вызовем функцию GetUserNameA

;   Для того чтобы получить название компьютера, выполним следующие действия:
    mov _size, szMAX_COMP_NAME   ; поместим в переменную _size значение размера строки названия компьютера (szMAX_COMP_NAME)
    lea RCX, _compname           ; загрузим АДРЕС строки в регистр RCX  
    lea RDX, _size               ; и УКАЗАТЕЛЬ на ее размер в регистр RDX
    call GetComputerNameA        ; вызовем функцию GetComputerNameA

;   Для того чтобы получить путь до директории временных файлов, выполним следующие действия:
    mov _size, szMAX_PATH       ; поместим в переменную _size значение размера строки пути до директории временных файлов (szMAX_PATH)
    lea RCX, _size              ; и УКАЗАТЕЛЬ на ее размер в регистр RCX
    lea RDX, _temppath          ; загрузим АДРЕС строки в регистр RDX  
    call GetTempPathA           ; вызовем функцию GetTempPathA

;   5.  Формирование отформатированной строки
;   Сформируем строку _msg с помощью функции wsprintfA:
    lea RCX, _msg           ;  поместим в регистр RCX адрес строки _msg
    lea RDX, fmt            ;  в RDX занесем адрес строки форматирования fmt
    lea R8, _username       ;  в регистры R8 и R9 поместим адреса _username и
    lea R9, _compname       ;  _compname соответственно
    lea RAX, _temppath      ;  поместим оставшиеся     ; error is kinda here
    mov [RSP + 32], RAX     ;  аргументы в стек
    
    call wsprintfA          ;  вызовем wsprintfA.
>>>>>>> Stashed changes

;   6.  Отображение полученной информации в диалоговом окне
;   Выведем полученную строку с помощью MessageBoxA:
    xor RCX, RCX            ;   обнулим регистры RCX 
    xor R9, R9              ;   и R9
    lea RDX,  _msg          ;   загрузим в RDX адрес строки для вывода на экран (_msg)
    lea R8,  cap            ;   загрузим в R8 адрес строки, содержащей заголовок окна (cap)
    call MessageBoxA        ;   вызовем MessageBoxA

;   7.  Завершение работы процесса
;   Выполним следующие действия:

    xor RCX, RCX     ;    обнулим RCX
    call ExitProcess ;    вызовем ExitProcess

Start endp
end