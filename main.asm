extrn GetUserNameA      : proc,
      GetComputerNameA  : proc,
      GetTempPathA      : proc,
      wsprintfA         : proc,
      MessageBoxA       : proc,
      ExitProcess       : proc


;   Удобно ввести следующие макрозамены (с помощью директивы equ или =):
    szMAX_COMP_NAME equ 16
    szUNLEN         equ 257
    szMAX_PATH      equ 261

.data


;   Введите следующие глобальные переменные (заголовок окна и строка форматирования):	
    
    cap db 'PC INFO',       0

    fmt db 'Username: %s',           0Ah,   ; 0Ah = \n in ASCII TABLE
           'Computer name: %s',      0Ah,
           'TMP Path: %s',           0

.code
Start proc
;   Пошаговая инструкция по написанию программы
;
;   HELLO!
;
;   1.  Объявление локальных переменных
;   Для хранения результатов вызовов функций WinAPI введем следующие локальные переменные :


    local _msg[1024]                :byte, ; В переменной _msg будет храниться результирующая строка размером до 1024 байт
      _username[szUNLEN]            :byte, ; имя пользователя
      _compname[szMAX_COMP_NAME]    :byte, ; название компьютера
      _temppath[szMAX_PATH]         :byte, ; путь до директории временных файлов
      _size                         :dword

;   В переменной _msg будет храниться результирующая строка размером до 1024 байт. 
;   Байтовые переменные 
;   _username[szUNLEN], 
;   _compname[szMAX_COMP_NAME], 
;   _temppath[szMAX_PATH] 
;   нужны для хранения 
;   имени пользователя, 
;   названия компьютера
;   и пути до директории временных файлов
;   соответственно. 
;   Последняя переменная, которую необходимо объявить, - это _size размера dword. 
;   Эта переменная необходима для передачи размера строк в функции 
;   (так как размер требуется передать по указателю, макрозамены для передачи мы использовать не можем).    


;   2.  Подготовка стека
;   Для того, чтобы начать работу с WinAPI, требуется подготовить стек: 
;   выровнять его в соответствии со стандартом __fastcall и выделить место под 5 аргументов:

    sub RSP, 8*5
    and SPL, 0F0h ; 0000 

;   3.  Получение имени пользователя, названия компьютера и пути до директории временных файлов
;   Для того чтобы получить имя пользователя, выполним следующие действия:

    mov _size, szUNLEN          ; поместим в переменную _size значение размера строки имени пользователя (szUNLEN)
    lea RCX, _username          ; загрузим АДРЕС строки и УКАЗАТЕЛЬ на ее размер в регистры RCX  
    lea RDX, _size              ; и RDX соответственно
    call GetUserNameA           ; вызовем функцию GetUserNameA

;   Для того чтобы получить название компьютера, выполним следующие действия:
    mov _size, szMAX_COMP_NAME   ; поместим в переменную _size значение размера строки названия компьютера (szMAX_COMP_NAME)
    lea RCX, _compname           ; загрузим АДРЕС строки в регистр RCX  
    lea RDX, _size               ; и УКАЗАТЕЛЬ на ее размер в регистр RDX
    call GetComputerNameA        ; вызовем функцию GetComputerNameA

;   Для того чтобы получить путь до директории временных файлов, выполним следующие действия:
    mov _size, szMAX_PATH       ; поместим в переменную _size значение размера строки пути до директории временных файлов (szMAX_PATH)
    lea RCX, _size              ; и УКАЗАТЕЛЬ на ее размер в регистр RCX
    lea RDX, _temppath          ; загрузим АДРЕС строки в регистр RDX  
    call GetTempPathA           ; вызовем функцию GetTempPathA

;   5.  Формирование отформатированной строки
;   Сформируем строку _msg с помощью функции wsprintfA:
    lea RCX, _msg       ;  поместим в регистр RCX адрес строки _msg
    lea RDX, fmt        ;  в RDX занесем адрес строки форматирования fmt
    lea R8, _username   ;  в регистры R8 и R9 поместим адреса _username и
    lea R9, _compname   ;  _compname соответственно
    lea RAX, _temppath  ;  поместим оставшиеся     ; error is kinda here
    mov [RSP + 32], RAX            ;  аргументы в стек
    call wsprintfA      ;  вызовем wsprintfA.

;   6.  Отображение полученной информации в диалоговом окне
;   Выведем полученную строку с помощью MessageBoxA:
    xor RCX, RCX            ;   обнулим регистры RCX 
    xor R9, R9              ;   и R9
    lea RDX,  _msg          ;   загрузим в RDX адрес строки для вывода на экран (_msg)
    lea R8,  cap            ;   загрузим в R8 адрес строки, содержащей заголовок окна (cap)
    call MessageBoxA        ;   вызовем MessageBoxA

;   7.  Завершение работы процесса
;   Выполним следующие действия:

    xor RCX, RCX     ;    обнулим RCX
    call ExitProcess ;    вызовем ExitProcess

Start endp
end